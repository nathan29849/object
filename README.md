# object
조영호님의 Object 책을 보고 따라해보는 레포지토리입니다.

---

## 1장 객체, 설계

### 변경에 취약한 코드를 변경에 유연할 수 있는 코드로 바꾸자!

- 객체 사이의 `의존성(dependency)`과 관련된 문제
  - 어떤 객체가 변경될 때, 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다. (의존성을 check 하는 방법이기도 함)
  - but, `의존성`을 완전히 없애는 것이 정답은 아님
  - 객체지향 설계는 서로 의존하면서, 협력하는 객체들의 공동체를 구축하는 것
  - 따라서, 최소한의 의존성만 유지하고 불필요한 의존성을 제거하자!
  - 캡슐화를 통해서 객체를 자율적인 존재로 만들자. (각 객체에 책임이 적절히 분리될 수 있도록)

- 객체의 `응집도(cohesion)`을 높이려면?
  - 객체 스스로 자신의 데이터를 책임져야 한다. (자신의 데이터를 스스로 처리)

- 객체지향 설계의 핵심
  - 적절한 객체에 적절한 책임 할당하기
  - 객체가 어떤 데이터를 갖냐보다, **객체에 어떤 책임을 할당할 것이냐**에 초점을 맞추자

### 결국 훌륭한 설계는 적절한 트레이드 오프의 결과물이다.
- 결합도를 낮추는 것 vs 객체의 자율성을 높이는 것

---

## 2장 객체지향 프로그래밍

### 협력, 객체, 클래스
- 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 **"객체"** 에 초점을 맞출 때에만 얻을 수 있다.
  1. 어떤 클래스가 필요한지 고민하기 전, **어떤 객체들이 필요한지** 고민하자
     - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한 것. 따라서 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 함
  2. 객체를 독립적인 존재로 보지 말고, 협력하는 공동체의 일원으로 보라.
     - 설계를 유연하고 확장가능하게 만든다.
- 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고, 이 타입을 기반으로 클래스를 구현하자.

### 도메인
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다.
- 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

### 클래스 구현하기
- 클래스의 내부와 외부를 구분해야 하는 이유? (캡슐화를 해야하는 이유)
  - 경계의 명확성이 객체의 자율성을 보장
    - 객체 지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것. 따라서 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.
    - 따라서 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.
  - 프로그래머에게 구현의 자유를 제공
    - 프로그래머의 역할은 클래스 작성자와 클라이언트 프로그래머로 나눌 수 있다.
    - 이 때, 클라이언트 프로그래머는 (클래스 작성자가) 숨겨 높은 부분을 마음대로 접근할 수 없으므로, 클래스 작성자는 이에 대한 영향을 걱정하지 않고, 내부 구현을 마음대로 변경할 수 있다.
    - 객체의 내부와 외부를 구분했을 때, 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고, 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

- 설계가 필요한 이유 : 변경을 관리하기 위함

### 협력하는 객체들의 공동체
- 객체지향의 장점 : 객체를 이용해 도메인의 의미를 풍부하게 표현 가능
- 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면, 객체를 사용해서, 해당 개념을 구현하자.
  - 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 길이다.

### 협력에 관한 짧은 이야기
 
- 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 한다.
- `메서드를 호출한다`보다는 `메시지를 전송한다`라고 표현하는 것이 더 적절하다.
- 메시지를 수신한 객체는 스스로 적절한 메서드를 찾아 응답한다. (객체가 자율적으로 결정)
- 메시지와 메서드를 구분하는 것은 매우 중요하다. 이것으로 부터 **다형성(polymorphism)** 의 개념이 출발하기 때문이다.

### TEMPLATE METHOD 패턴
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

### 컴파일 시간 의존성과 실행 시간 의존성
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
- 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
  - 코드를 이해하기 위해서, 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야하기 때문
  - 반면, 코드의 의존성과 실행 시점의 의존성이 다를수록 코드는 더 유연해지고 확장가능해 짐
  - 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 것을 잘 보여줌
  - 따라서 항상 가독성 vs 유연성을 고민해야 한다.

### 차이에 의한 프로그래밍
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

### 상속과 인터페이스
- 인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의
- 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 됨
- 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에, 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주
  - 협력하는 객체가 메시지를 수신할 수만 있다면, 어떤 클래스의 인스턴스인지 상관이 없다는 뜻이기도 하다.
- 컴파일러는 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
- 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(Upcasting)이라 한다.

### 다형성
- 다형성 : 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇인지에 따라 달라짐
- 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.(인터페이스가 동일해야 한다는 뜻 -> 상속을 통해 가능함)
  - but 상속이 유일한 방법은 아님 (다형성이라는 추상적 개념을 구현할 수 있는 방법은 꽤나 다양하다고 한다. -> 추후 학습)
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
  - 이게 가능한 이유는 동적 바인딩(dynamic binding) 또는 지연 바인딩(lazy binding)을 사용하기 때문

>- 구현 상속(implementation inheritance)은 서브클래싱(subclassing)이라고 부른다.
>- 인터페이스 상속(interface inheritance)은 서브타이핑(subtyping)이라고 부른다.  

### 추상 클래스와 인터페이스 트레이드오프
- 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.
- 모든 코드에는 합당한 이유가 있어야 한다.
- 아주 사소한 결정이라도, 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.
- 꼭 고민하고 트레이드 오프하도록 하자.

### 코드 재사용 (상속 vs 합성)
- 합성(Composition) : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
  - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법임
- 상속의 문제점
  - 캡슐화 위반(부모 클래스의 구현이 자식 클래스에게 노출되기 때문)
  - 설계의 유연성 저하(상속은 컴파일 시점에 부모 클래스와 자식 클래스 사이의 관계를 결정 -> 실행 시점에 객체 종류 바꾸는 것이 불가능)
- 합성이 상속보다 더 유연한 설계를 할 수 있다. (인터페이스를 통해 약하게 결합하기 때문)
