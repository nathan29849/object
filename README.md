# object
조영호님의 Object 책을 보고 따라해보는 레포지토리입니다.

---

## 1장 객체, 설계

### 변경에 취약한 코드를 변경에 유연할 수 있는 코드로 바꾸자!

- 객체 사이의 `의존성(dependency)`과 관련된 문제
  - 어떤 객체가 변경될 때, 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다. (의존성을 check 하는 방법이기도 함)
  - but, `의존성`을 완전히 없애는 것이 정답은 아님
  - 객체지향 설계는 서로 의존하면서, 협력하는 객체들의 공동체를 구축하는 것
  - 따라서, 최소한의 의존성만 유지하고 불필요한 의존성을 제거하자!
  - 캡슐화를 통해서 객체를 자율적인 존재로 만들자. (각 객체에 책임이 적절히 분리될 수 있도록)

- 객체의 `응집도(cohesion)`을 높이려면?
  - 객체 스스로 자신의 데이터를 책임져야 한다. (자신의 데이터를 스스로 처리)

- 객체지향 설계의 핵심
  - 적절한 객체에 적절한 책임 할당하기
  - 객체가 어떤 데이터를 갖냐보다, **객체에 어떤 책임을 할당할 것이냐**에 초점을 맞추자

### 결국 훌륭한 설계는 적절한 트레이드 오프의 결과물이다.
- 결합도를 낮추는 것 vs 객체의 자율성을 높이는 것

---

## 2장 객체지향 프로그래밍

### 협력, 객체, 클래스
- 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 **"객체"** 에 초점을 맞출 때에만 얻을 수 있다.
  1. 어떤 클래스가 필요한지 고민하기 전, **어떤 객체들이 필요한지** 고민하자
     - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한 것. 따라서 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 함
  2. 객체를 독립적인 존재로 보지 말고, 협력하는 공동체의 일원으로 보라.
     - 설계를 유연하고 확장가능하게 만든다.
- 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고, 이 타입을 기반으로 클래스를 구현하자.

### 도메인
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다.
- 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

### 클래스 구현하기
- 클래스의 내부와 외부를 구분해야 하는 이유? (캡슐화를 해야하는 이유)
  - 경계의 명확성이 객체의 자율성을 보장
    - 객체 지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것. 따라서 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.
    - 따라서 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.
  - 프로그래머에게 구현의 자유를 제공
    - 프로그래머의 역할은 클래스 작성자와 클라이언트 프로그래머로 나눌 수 있다.
    - 이 때, 클라이언트 프로그래머는 (클래스 작성자가) 숨겨 높은 부분을 마음대로 접근할 수 없으므로, 클래스 작성자는 이에 대한 영향을 걱정하지 않고, 내부 구현을 마음대로 변경할 수 있다.
    - 객체의 내부와 외부를 구분했을 때, 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고, 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

- 설계가 필요한 이유 : 변경을 관리하기 위함

### 협력하는 객체들의 공동체
- 객체지향의 장점 : 객체를 이용해 도메인의 의미를 풍부하게 표현 가능
- 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면, 객체를 사용해서, 해당 개념을 구현하자.
  - 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 길이다.

### 협력에 관한 짧은 이야기
 
- 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 한다.
- `메서드를 호출한다`보다는 `메시지를 전송한다`라고 표현하는 것이 더 적절하다.
- 메시지를 수신한 객체는 스스로 적절한 메서드를 찾아 응답한다. (객체가 자율적으로 결정)
- 메시지와 메서드를 구분하는 것은 매우 중요하다. 이것으로 부터 **다형성(polymorphism)** 의 개념이 출발하기 때문이다.

### TEMPLATE METHOD 패턴
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

### 컴파일 시간 의존성과 실행 시간 의존성
- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
- 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
  - 코드를 이해하기 위해서, 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야하기 때문
  - 반면, 코드의 의존성과 실행 시점의 의존성이 다를수록 코드는 더 유연해지고 확장가능해 짐
  - 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 것을 잘 보여줌
  - 따라서 항상 가독성 vs 유연성을 고민해야 한다.

### 차이에 의한 프로그래밍
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

### 상속과 인터페이스
- 인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의
- 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 됨
- 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에, 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주
  - 협력하는 객체가 메시지를 수신할 수만 있다면, 어떤 클래스의 인스턴스인지 상관이 없다는 뜻이기도 하다.
- 컴파일러는 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
- 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(Upcasting)이라 한다.

### 다형성
- 다형성 : 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇인지에 따라 달라짐
- 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.(인터페이스가 동일해야 한다는 뜻 -> 상속을 통해 가능함)
  - but 상속이 유일한 방법은 아님 (다형성이라는 추상적 개념을 구현할 수 있는 방법은 꽤나 다양하다고 한다. -> 추후 학습)
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
  - 이게 가능한 이유는 동적 바인딩(dynamic binding) 또는 지연 바인딩(lazy binding)을 사용하기 때문

>- 구현 상속(implementation inheritance)은 서브클래싱(subclassing)이라고 부른다.
>- 인터페이스 상속(interface inheritance)은 서브타이핑(subtyping)이라고 부른다.  

### 추상 클래스와 인터페이스 트레이드오프
- 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.
- 모든 코드에는 합당한 이유가 있어야 한다.
- 아주 사소한 결정이라도, 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.
- 꼭 고민하고 트레이드 오프하도록 하자.

### 코드 재사용 (상속 vs 합성)
- 합성(Composition) : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
  - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법임
- 상속의 문제점
  - 캡슐화 위반(부모 클래스의 구현이 자식 클래스에게 노출되기 때문)
  - 설계의 유연성 저하(상속은 컴파일 시점에 부모 클래스와 자식 클래스 사이의 관계를 결정 -> 실행 시점에 객체 종류 바꾸는 것이 불가능)
- 합성이 상속보다 더 유연한 설계를 할 수 있다. (인터페이스를 통해 약하게 결합하기 때문)

---

# 3장 역할, 책임, 협력

- 협력 : 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
- 책임 : 객체가 협력에 참여하기 위해 수행하는 행동
- 역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 구성된 것

## 1) 협력
- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작됨
- 메시지 전송 : 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단
- 메서드 실행 : 메시지를 수신한 객체가 요청에 응답하는 방법 (객체가 스스로 선택)

- 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상 시킬 수 있다.
  - 구현 측면) 내부 구현을 캡슐화함으로써 자율성을 높일 수 있다.

### 협력이 설계를 위한 문맥을 결정한다.
- 상태 : 객체가 행동하는 데 필요한 정보에 의해 결정됨
- 행동 : 협력 안에서 객체가 처리할 메시지로 결정됨
- 결과적으로, 객체가 참여하는 "협력"이 객체를 구성하는 행동과 상태를 모두 결정
- 따라서 협력은 객체를 설계하는데 필요한 일종의 "문맥"을 제공

## 2) 책임
- 책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합 
- 객체의 책임은 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성
  - 하는 것
    - 객체를 생성하거나 수행하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
  - 아는 것
    - 사적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 사실 협력이 중요했던 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문
- 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정
- 구현 방법은 상대적으로 덜 중요한 것
- 객체지향 설계는 협력에 필요한 메시지를 찾고, 메시지에 적절한 객체를 선택하는 반복적인 과정 (메시지가 객체를 선택하게 하라)
  - 객체는 최소한의 인터페이스를 가질 수 있게 된다.
  - 객체는 추상적인 인터페이스를 가질 수 있게 된다.
- 기본 전략 : 책임을 수행할 정보 전문가를 찾고, 책임을 할당하자 -> 상태와 행동을 함께 가지는 자율적 객체를 만들 가능성 높아짐

### 책임 주도 설계
- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

- 과정
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
  - 시스템 책임을 더 작은 책임으로 분할
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할 찾기
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 됨

### 행동이 상태를 결정한다.
- 협력이 객체 행동(책임) 결정 -> 행동(책임)이 상태를 결정 
- 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루고, 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 함
- 협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고, 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.

## 3) 역할
### 역할과 협력
- 역할 : 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합 
- 실제로 협력을 모델링 할 때, 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하자

### 유연하고 재사용 가능한 협력
- 역할이 중요한 이유 : 유연하고 재사용 가능한 협력을 얻을 수 있기 때문
- 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합하여 불필요한 중복 코드를 지울 수 있게 해준다.
  - 이로 인해 새로운 협력을 추가할 필요가 없어짐!

### 역할의 구현
- 역할을 구현하는 가장 일반적 방법 : 추상 클래스와 인터페이스
  - why? 책임의 집합을 서술하기 때문
  - 추상 클래스는 책임의 일부를 구현해 놓은 것이고, 인터페이스는 일체 구현 없이 책임의 집합만 나열

### 객체 대 역할
- 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.
- 만약, 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.
- 중요한 것은 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다.
- 따라서 역할의 가장 큰 장점은 <u>**설계의 구성 요소를 추상화할 수 있다**</u> 는 것이다.

### 역할과 추상화
- 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에, 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.
- 따라서 추상화가 가지는 두 가지 장점은 협력의 관점에서 역할에도 동일하게 적용
  - 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화 가능
  - 설계가 유연해짐 (역할이 다양한 종류의 객체를 끼워 넣을 수 있는 일종읫 슬롯이라는 점을 생각하자)


